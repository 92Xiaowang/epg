# 工作流名称：生成电子节目指南（EPG）
name: Generate epg

# 权限设置：允许写入仓库内容（用于创建Release等操作）
permissions:
  contents: write  # 确保有创建Release的权限

# 触发条件：支持手动触发和定时触发
on:
  workflow_dispatch:  # 允许手动触发工作流
  schedule:
 #   - cron: '0 */6 * * *'  # 定时触发，每6小时执行一次（分 时 日 月 周，GitHub Actions默认使用UTC时间，实际执行时间为UTC+8的10:00、16:00、22:00、04:00）
     - cron: '0 0 * * *' # 改为每天UTC时间0点执行（对应北京时间早上8点）

# 定义作业
jobs:
  process-xml:  # 作业名称：处理XML文件
    runs-on: ubuntu-latest  # 运行环境：最新版Ubuntu系统

    steps:  # 作业步骤
      - name: Checkout code  # 步骤1：拉取仓库代码
        uses: actions/checkout@v4  # 使用官方checkout动作，版本v4
        with:
          persist-credentials: true  # 保留凭证，方便以便后续git操作

      - name: Set up environment  # 步骤2：配置运行环境（设置时区为北京时间）
        run: |  # 执行bash命令
          sudo apt-get update  # 更新软件源
          sudo apt-get install -y xmlstarlet gzip tzdata  # 安装必要工具和时区数据
          sudo ln -snf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime  # 设置系统时区为北京时间（Asia/Shanghai）
          echo "Asia/Shanghai" | sudo tee /etc/timezone  # 写入时区配置

      - name: Download e.xml  # 步骤3：下载原始EPG文件
        run: |
          curl -o e.xml "http://epg.51zmt.top:8000/e1.xml"  # 使用curl下载文件并保存为e.xml
          if [ ! -s "e.xml" ]; then  # 检查文件是否下载成功且非空
            echo "Failed to download e.xml"  # 输出错误信息
            exit 1  # 退出并返回错误码1
          fi

      - name: Process XML and filter programs  # 步骤4：处理XML，筛选前五天、今天和明天的节目
        run: |
          # 获取当前北京时间的日期部分（格式：YYYYMMDD）
          TODAY=$(date +'%Y%m%d')
          # 获取明天北京时间的日期部分
          TOMORROW=$(date -d '+1 day' +'%Y%m%d')
          # 获取前5天的日期（从今天往前推5天）
          FIVE_DAYS_AGO=$(date -d '-5 days' +'%Y%m%d')
          # 获取当前北京时间（格式：年-月-日 时:分:秒）
          BEIJING_TIME=$(date +'%Y-%m-%d %H:%M:%S')
          
          echo "保留日期范围：前五天($FIVE_DAYS_AGO) 到 明天($TOMORROW)"
          
          # 生成日期筛选条件
          DATE_FILTER=""
          current_date=$(date -d '-5 days' +'%Y%m%d')
          # 循环生成从今天往前推5天到明天的日期条件
          for i in $(seq 0 6); do
            DATE=$(date -d "$FIVE_DAYS_AGO +${i} days" +'%Y%m%d')
            if [ "$i" -eq 0 ]; then
              DATE_FILTER="contains(@start, '$DATE')"
            else
              DATE_FILTER="$DATE_FILTER or contains(@start, '$DATE')"
            fi
          done
          
          # 使用xmlstarlet处理XML
          # 1. 移除所有desc节点
          # 2. 移除tv标签除generator-info-name外的所有其他属性
          # 3. 设置generator-info-name为mrwang
          # 4. 添加date属性
          # 5. 筛选只保留前五天、今天和明天的节目
          xmlstarlet ed \
            -d "//desc" \
            -d "//tv/@*[name() != 'generator-info-name']" \
            -u "//tv/@generator-info-name" -v "mrwang" \
            -i "//tv[not(@date)]" -t attr -n "date" -v "$BEIJING_TIME" \
            -u "//tv/@date" -v "$BEIJING_TIME" \
            e.xml > temp.xml
          
          # 筛选只保留前五天、今天和明天的节目
          xmlstarlet ed \
            -d "//programme[not($DATE_FILTER)]" \
            temp.xml > t.xml
          
          # 清理临时文件
          rm -f temp.xml
          
          if [ ! -s "t.xml" ]; then  # 检查处理后的文件是否生成成功且非空
            echo "Failed to generate t.xml"
            exit 1
          fi
          
          # 输出过滤后的节目数量统计
          PROGRAM_COUNT=$(xmlstarlet sel -t -v "count(//programme)" t.xml)
          echo "保留的节目总数: $PROGRAM_COUNT"
          
          # 统计每天的节目数量
          echo "=== 各日期节目数量统计 ==="
          current_date=$(date -d '-5 days' +'%Y%m%d')
          for i in $(seq 0 6); do
            DATE=$(date -d "$FIVE_DAYS_AGO +${i} days" +'%Y%m%d')
            DATE_FORMATTED=$(date -d "$DATE" +'%Y-%m-%d')
            COUNT=$(xmlstarlet sel -t -v "count(//programme[contains(@start, '$DATE')])" t.xml)
            echo "$DATE_FORMATTED: $COUNT 个节目"
          done
          
          # 验证tv标签属性
          echo "=== 验证tv标签属性 ==="
          xmlstarlet sel -t -m "//tv" -o "tv: " -v "@generator-info-name" -o ", date: " -v "@date" -n t.xml

      - name: Create gzip archive  # 步骤5：创建gzip压缩文件
        run: |
          gzip -c t.xml > t.xml.gz  # 将t.xml压缩为t.xml.gz（-c表示输出到标准输出）
          if [ ! -s "t.xml.gz" ]; then  # 检查压缩文件是否生成成功且非空
            echo "Failed to generate t.xml.gz"
            exit 1
          fi

      - name: Save files to epg folder  # 步骤6：将文件保存到epg文件夹
        run: |
          mkdir -p epg  # 创建epg文件夹（-p确保父目录存在，若已存在则不报错）
          cp t.xml epg/t.xml  # 复制t.xml到epg文件夹
          cp t.xml.gz epg/t.xml.gz  # 复制t.xml.gz到epg文件夹
          # 检查文件夹和文件是否存在
          if [ ! -d "epg" ] || [ ! -f "epg/t.xml" ] || [ ! -f "epg/t.xml.gz" ]; then
            echo "Files or folder missing"
            exit 1
          fi

      - name: Commit and push changes  # 步骤7：提交并推送更改到仓库（使用北京时间）
        run: |
          # 配置git用户信息（使用GitHub Actions默认身份）
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git add epg/  # 将epg文件夹添加到暂存区
          # 提交更改，使用北京时间作为提交信息（若没有更改则输出提示信息）
          git commit -m "Update epg at $(date +'%Y-%m-%d %H:%M:%S')" || echo "No changes"
          git push origin main  # 推送到main分支

      - name: Manage latest tag  # 步骤8：管理latest标签（确保始终指向最新版本）
        run: |
          git tag -d latest || true  # 删除本地latest标签（若存在）
          git push origin --delete latest || true  # 删除远程latest标签（若存在）
          git tag -a latest -m "Latest EPG release at $(date +'%Y-%m-%d %H:%M:%S')"  # 标签注释使用北京时间
          git push origin latest  # 推送新的latest标签到远程仓库
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # 使用GitHub提供的令牌进行认证

      - name: Create正式Release  # 步骤9：创建正式发布版本
        uses: softprops/action-gh-release@v2  # 使用第三方gh-release动作，版本v2
        with:
          tag_name: latest  # 关联的标签名称为latest
          name: EPG # Release名称
          files: |  # 需要包含在Release中的文件
            epg/t.xml
            epg/t.xml.gz
          overwrite_files: true  # 允许覆盖已存在的文件
          draft: false       # 不设为草稿
          prerelease: false  # 不设为预发布版本
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # 使用GitHub令牌授权
